#summary ver0.3の新機能と改良点

= ver0.3の特徴：概観 =

これまで，本フレームワークは，下記のような進歩を遂げてきた。

 * ver0.1：AndroidアプリにおけるMVCアーキテクチャの骨組みを示した。

 * ver0.2：MVCアーキテクチャの構造を強化し，レイヤ間の連携を容易にした。

<br>

そして今回，ver0.3では，「実用性」を向上させる事に主眼を置いたリリースとなった。

 * ver0.3：サンプルアプリ充実，および他ツールの特徴を導入。実用性を向上させた。

<br>

各レイヤごとに，機能面での主な改良点を取り上げる。

 * *View層*
   * UIを，４通りの方法で実装可能になった。HTML5やjQuery Mobile，またJS+CSSなど既存のWeb制作技術を使った画面構築をサポート。
   * MapViewの扱いが極めて容易になった。現在地の追跡や，マップ上のアイコン描画をサポート。
   * Viewのアニメーションの連続実行を可能にするようなライブラリを提供。

 * *Controller層*
   * サービス（バッチ）で，定期的にタスクを実行するような常駐型の仕組みを容易に実現可能になった。
   * 端末ブート時に起動するサービスも容易に実現可能になった。
   * 複数の非同期タスクを逐次的に連続実行する際，イベント駆動型のタスクも実行できるようになった。
   * GPSで現在地を取得する処理を容易に実現可能になった。位置情報の変換ユーティリティ付き。
   * コントロールフローをより簡潔にカスタマイズ可能に。ダイアログの文言や，BLを介さない画面遷移など。

 * *Model層*
   * ORMで，論理エンティティと物理エンティティの相互変換をスマートに実行するための方式を整備した。
   * RDBの初期状態の定義を簡潔にした。カラムに論理名コメントを付与可能になり，初期データ投入も統合。
   * SELECT時にLIMITとOFFSETを指定可能にした。

<br>

これらの特徴は，同梱のサンプルアプリを動作させて確認することができる。

下記では，これらの特徴を，サンプルコードを引用しつつ詳細に説明する。
<br>

<hr><br>

= ver0.3の特徴：詳細 =

ver0.2の時に倣って，V→C→Mの順に見てゆく。

<hr><br>

== View層： ==

== ■ UIを，４通りの方法で実装可能になった。HTML5やjQuery Mobile，またJS+CSSなど既存のWeb制作技術を使った画面構築をサポート。 ==

もともと，従来のレイアウトXMLによる画面描画方法に加えて，UIBuilderクラスを使った手軽なUI構築が可能な造りとなっていた。

この方法は，画面のプロトタイプ構築などの際に威力を発揮することだろう。


今回ver0.3では，他のAndroidアプリ開発フレームワークの特徴を導入した。

即ち，<b>HTML5等を使ったUI構築</b>である。


素のHTML4と，JavaScriptとJavaを連携させる仕組みのサンプルコードは，下記を参照。


 SampleHtmlActivity.java<br>
 http://code.google.com/p/android-mvc-framework/source/browse/tags/20120730_ver0.3/src/com/android_mvc/sample_project/activities/func_html/SampleHtmlActivity.java


HTML5と，jQuery Mobileを使ったUI構築のサンプルコードは，下記のアクティビティを参照。

 SampleJQueryMobileActivity.java<br>
 http://code.google.com/p/android-mvc-framework/source/browse/tags/20120730_ver0.3/src/com/android_mvc/sample_project/activities/func_html/SampleJQueryMobileActivity.java


これらの機能を実現するためには，下記のエントリが参考になった。

 たった２ファイルで，HTML＋JS製のネイティブAndroidアプリを作る手順　（動作するサンプルコード付き。WebViewの活用方法）
 http://d.hatena.ne.jp/language_and_engineering/20120710/CreateAndroidAppByHtml5JavaScript
 
 AndroidやiOSの「ハイブリッドアプリ」で，JavaScriptとネイティブ・コードが連携する仕組みを図解　（おまけ：HTML側で施すべき，クロスプラットフォーム対策）
 http://d.hatena.ne.jp/language_and_engineering/20120713/p1
 
 Javaで，匿名クラス内で定義したpublicメソッドの警告が消せず困った話　（静的なJavaと，動的なJavaScriptを連携させるDSLを作りたい）
 http://d.hatena.ne.jp/language_and_engineering/20120728/AnonymousClassWarnsOnBridgingBetweenJavaAndJS


== ■ MapViewの扱いが極めて容易になった。現在地の追跡や，マップ上のアイコン描画をサポート。 ==

MapViewを拡張したMMapViewの作成により，マップアプリの開発工数が劇的に削減される。

マップ上では，自分の現在地を自動的に追跡させる事もできるし，任意の座標にアイコンを描画する事も容易である。

下記が該当するサンプルコード。

 SampleMapActivity.java
 http://code.google.com/p/android-mvc-framework/source/browse/tags/20120730_ver0.3/src/com/android_mvc/sample_project/activities/func_map/SampleMapActivity.java


Mapを利用するためには，Eclipse上でプロジェクトを新規作成する際に，ターゲットとしてGoogle APIを含むようなセットアップが必要である。

また，strings.xmlの中に，自分の取得したGoogle Maps APIのキーを記述しておくことが必要だ。


これらの機能を実現するためには，下記のエントリが参考になった。

 Androidアプリで，Google Maps API＋GPS＋Geocoderを使って，現在地の地図と地名を表示させよう
 http://d.hatena.ne.jp/language_and_engineering/20110828/p1
 
 Androidアプリで，Google Mapsの地図上にアイコン画像を配置し，そのTapイベントに反応するサンプルコード
 http://d.hatena.ne.jp/language_and_engineering/20110907/p1



== ■ Viewのアニメーションの連続実行を可能にするようなライブラリを提供。 ==

AndroidのアニメーションAPIには，「連続実行がしづらい」という欠点があった。

しかし，それを解消するような便利なライブラリが提供された。

AnimationDescriptionを列挙するだけで，時系列にアニメーションが実行されるのである。

 SampleAnimationActivity.java
 http://code.google.com/p/android-mvc-framework/source/browse/tags/20120730_ver0.3/src/com/android_mvc/sample_project/activities/func_visual/SampleAnimationActivity.java

この機能を実現するためには，下記のエントリが役立った。

 Androidで，複数のAnimationを「順番に」実行するためのライブラリ　（XMLを使わずに「連続した動きの変化」を指定し，逐次実行するDSL）
 http://d.hatena.ne.jp/language_and_engineering/20120416/AndroidAnimationSetSequentialDSL
 
 Androidで，「ビットマップのピクセル操作」をリアルタイムに実行するサンプルコード
 http://d.hatena.ne.jp/language_and_engineering/20120626/AndroidManipulateBitmapPixels

ただし，本機能には限界もある。利用時には，１個のViewに対する操作にとどめられたい。


<br><hr><br>


== Controller層： ==





<br><hr><br>


== Model層 ==

== ■ORMの機能が強化された。CRUDの処理は最初から組み込み済みになった。 ==

RDBの操作は，CRUDのいずれも極めてシンプルかつ明快なコードになった。

下記のサンプルを見れば，一目瞭然であろう。

{{{

    // ------------ C --------------


    /**
     * 1人の友達を保存。
     */
    public Friend create(String name, Integer age, Boolean favoriteFlag)
    {
        // 論理エンティティを構築
        Friend f = new Friend();
        f.setName(name);
        f.setAge( age );
        f.setFavorite_flag( favoriteFlag );

        // DB登録
        f.save(helper);

        return f;
    }


    // ------------ R --------------


    /**
     * 友達を全て新しい順に返す。
     */
    public ArrayList<Friend> findAll()
    {
        return findAll(helper, Friend.class);
    }


    /**
     * 特定のIDの友達を１人返す。
     */
    public Friend findById(Long friend_id)
    {
        return findById( helper, Friend.class, friend_id );
    }

        // NOTE: 細かい条件で検索したい場合は，Finderを利用すること。
        // findAllやfindByIdの実装を参照。


    // ------------ U --------------


    /**
     * 既存の友達のお気に入り状態を反転させる。
     */
    public Friend invertFavoriteFlag( Long friend_id )
    {
        // idをもとに検索
        Friend f = findById( friend_id );

        // フラグを反転する
        f.setFavorite_flag( ! f.getFavorite_flag() );

        // DB更新
        f.save(helper);

        return f;
    }


    // ------------ D --------------


    /**
     * 特定のIDの友達を削除。
     */
    public void deleteById( Long friend_id )
    {
        Friend f = findById(friend_id);

        // DBからの削除を実行
        f.delete(helper);
    }

}}}

DAO自体が，findAll() とかfindById()みたいなメソッドを持つようになった。

またエンティティ自体，save()で新規登録と更新の両方が可能になり，delete()メソッドで自身の削除も可能となった。

DB操作のためのユーザのコード記述量は，圧倒的に削減された。

 引用元：FriendDAO.java<br>
 http://code.google.com/p/android-mvc-framework/source/browse/tags/20120323_ver0.2/src/com/android_mvc/sample_project/db/dao/FriendDAO.java


それだけではなく，SELECT文を発行する際には，細かい条件を指定する事も可能である。

findAll()やfindById()の実装を見ればわかる。

{{{
    /**
     * レコードを全て新しい順に返す。
     */
    public ArrayList<T> findAll(DBHelper helper, Class<T> entity_class)
    {
        // 有効な湯キーを持つ全件を降順に
        return new Finder<T>(helper)
            .where("id > 0")
            .orderBy("id DESC")
            .findAll(entity_class)
        ;
    }

}}}

ユーザは，このコードを模倣して，任意の検索条件を持った検索メソッドを実装可能である。

 引用元：BaseDAO.java<br>
 http://code.google.com/p/android-mvc-framework/source/browse/tags/20120323_ver0.2/src/com/android_mvc/framework/db/dao/BaseDAO.java

なお，このFinderオブジェクトの考案にあたっては，Ruby on Rails3のActiveRecordのエンジン「Arel」を意識した。


<br><hr><br>


== 結び ==

以上が，ver0.2における改良点のサマリである。

M・V・Cの全レイヤについて，DSLが提供され，ユーザのコード記述量が減り，生産性が劇的に向上しているのを分かって頂ける事と思う。


<br>
ver0.1は「MVCの骨組み」であった。

ver0.2は，MVCの構造がよりいっそう強固になり，Androidアプリ開発における「スタンダードな設計方針」を示し，それを理想的な実装コードの形態で具現化した。
<br>

この調子でバージョンアップを重ねていけば，あたかも既存の部品を手早く組み合わせるだけで素早くアプリを完成できるような，魅力的なフレームワークになってゆくのは間違いない。

ぜひ，次バージョンも楽しみにして頂きたい。



　