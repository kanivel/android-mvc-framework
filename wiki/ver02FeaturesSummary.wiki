#ver0.2の新機能と改良点

= ver0.2の特徴：概観 =

ver0.2では，MVCフレームワークとしての基本構造が，よりいっそう強固になった。
<br><br>

全体のアーキテクチャは，ver0.1の時とほぼ同様である。（※[ver01ArchitecturesAndDesignsSummary こちらのページ]のクラス図をご覧いただきたい。）
<br><br>

このアーキテクチャを基に，ver0.2では

 * M・V・Cの各 *レイヤ内部* の改良

 * M・V・Cの各 *レイヤ間連携* の改良

が施されている。
<br><br>

各レイヤごとに，機能面での主な改良点を取り上げる。

 * *View層*
   * オプションメニューを，気軽に構築可能になった。
   * タブレイアウトを，気軽に実現可能になった。
   * 文字列リソースの参照が極めて容易になった。

 * *Controller層*
   * より柔軟な制御フロー・処理フローを，より明快・簡潔なコードで実現可能になった。
   * バリデーション・ロジックが，きわめて簡潔に記述できるようになった。
   * エンティティを含む任意の自作オブジェクトが，Intent経由で気軽に運搬可能になった。


 * *Model層*
   * ORMの機能が強化された。CRUDの処理は最初から組み込み済みになった。

<br>

これらの特徴は，同梱のサンプルアプリを動作させて確認することができる。

下記では，これらの特徴を，サンプルコードを引用しつつ詳細に説明する。
<br>

<hr><br>

= ver0.2の特徴：詳細 =

説明の順番としては，V→C→Mの順に見てゆくのが一番わかりやすい。

<hr><br>

== View層 ==

=== ■オプションメニューを，気軽に構築可能になった。 ===

下記のようなコードをActivityに記述して，動的にオプションメニューを構築可能である。

{{{
        // オプションメニューを構築
        return new OptionMenuBuilder(context)
            .add(
                new OptionMenuDescription()
                {
                    @Override
                    protected String displayText() {return "DB登録";}

                    @Override
                    protected void onSelected() {
                        // 画面遷移
                        MainController.submit(activity, "EDIT_DB");
                    }
                }
            )
            .add(
                new OptionMenuDescription()
                {
                    @Override
                    protected String displayText() {return "DB閲覧";}

                    @Override
                    protected void onSelected() {
                        // 画面遷移
                        MainController.submit(activity, "VIEW_DB");
                    }
                }
            )
        ;
}}}

※オプションが選択された時には，Controllerを呼び出し，画面遷移などを実行させている。

 引用元：TopActivity.java<br>
 http://code.google.com/p/android-mvc-framework/source/browse/tags/20120323_ver0.2/src/com/android_mvc/sample_project/activities/main/TopActivity.java


=== ■タブレイアウトを，気軽に実現可能になった。 ===

下記のようなコードをActivityに記述して，動的にタブレイアウトを構築可能である。

{{{
        // タブの定義を記述する。
        new TabHostBuilder(context)
            .setChildActivities( FuncDBController.getChildActivities(this) )
            .add(
                new TabDescription("TAB_EDIT_DB")
                    .text("DB登録")
                    .icon(android.R.drawable.ic_menu_add)
                ,

                new TabDescription("TAB_VIEW_DB")
                    .text("DB閲覧")
                    .icon(android.R.drawable.ic_menu_agenda)
                ,

                new TabDescription("TAB_FUNC_NET")
                    .text("通信")
                    .noIcon()

            )
            .display()
        ;
}}}

各タブの中には，コンテンツとしてActivityを表示できる。

 引用元：SampleTabHostActivity.java<br>
 http://code.google.com/p/android-mvc-framework/source/browse/tags/20120323_ver0.2/src/com/android_mvc/sample_project/activities/func_db/SampleTabHostActivity.java


つまりView層では，一般のView部品に加えて，メニューやタブも動的に手軽に構築できるようになった。

レイアウトXMLに手を加える必要は一切ない。


=== ■文字列リソースの参照が極めて容易になった。 ===

文字列リソースはRクラスから取得するわけだが，その手間は，もはや手間ではなくなった。

Activity上のサンプルコード：

{{{
              tv2 = new MTextView(context)
                .text("このアプリの名称：" + $._(R.string.app_name) )
                .widthWrapContent()
}}}

このアイデアの着想については，下記のページを参照のこと。
型安全な方を採用してある。

 Androidアプリで，_("リソース名") と書くだけで，簡単に文字列を参照しよう<br>
 http://d.hatena.ne.jp/language_and_engineering/20110815/p1


なお「$」は，CommonActivityUtilのインスタンスである。

ver0.1では頭文字を取って「cau」という変数名で参照可能だったが，ver0.2ではこのように簡略化された。

View層の便利オブジェクトとして「$」という変数を利用する，という習慣は，特にWebアプリケーション開発に携わってきた者であれば，非常に親しみやすいだろう。

「$」は，今後もどんどん便利化していく計画である。

<br><hr><br>


== Controller層 ==

=== ■より柔軟な制御フロー・処理フローを，より明快・簡潔なコードで実現可能になった。 ===

コントローラ層では，処理フローが下記のように明確化された。

 * もし必要なら，Activityから受け取った値の *バリデーション。*

 * もしバリデーションを通過すれば， *ビジネスロジック（Action）* を実行。

 * ビジネスロジックの実行が完了したら，実行結果に基づいて， *遷移先の画面へルーティング。*

 * 最後に， *UI上で後処理* を実行。
<br>

これが，コントローラ層の要となるフローである。

もちろん，複雑な処理が無い場合は，ただ単に「Intentにデータを詰めて画面遷移するだけ」というのも可能。
<br>

サンプルを掲載する。

まずは，単純に画面遷移するだけのコード。Routerクラスが活躍する。

{{{
    /**
     * TOP画面からの遷移時
     */
    public static void submit(TopActivity activity, String button_type) {
        if( "EDIT_DB".equals(button_type) )
        {
            // 編集画面へ
            Router.goWithData(activity, DBEditActivity.class,
                new Intent().putExtra("hoge", "Intentで値を渡すテスト").putExtra("fuga", 1)
            );
        }
        else
        if( "VIEW_DB".equals(button_type) )
        {
            // 一覧画面へ
            Router.go(activity, DBListActivity.class);
        }
        else
        if( "TAB_SAMPLE".equals(button_type) )
        {
            // タブ画面へ
            Router.go(activity, SampleTabHostActivity.class);
        }
    }
}}}

goなら遷移するだけ。goWithDataなら，インテントにデータを詰め込んで運搬できる。

 引用元：MainController.java<br>
 http://code.google.com/p/android-mvc-framework/source/browse/tags/20120323_ver0.2/src/com/android_mvc/sample_project/controller/MainController.java


次に，バリデーション＋ビジネスロジック＋ルーティング＋UI後処理　というフローをフルに活用しているサンプルを掲載する。

{{{
    /**
     * DB登録画面からの遷移時
     */
    public static void submit(final DBEditActivity activity)
    {
        new ControlFlowDetail<DBEditActivity>( activity )
            .setValidation( new ValidationExecutor(){
                @Override
                public ValidationResult doValidate()
                {
                    // バリデーション処理
                    return new FuncDBValidation().validate( activity );
                }

                @Override
                public void onValidationFailed()
                {
                    showErrMessages();

                    // バリデーション失敗時の遷移先
                    //goOnValidationFailed( DBEditActivity.class );
                    stayInThisPage();
                }
            })
            .setBL( new BLExecutor(){
                @Override
                public ActionResult doAction()
                {
                    // BL
                    return new DBEditAction( activity ).exec();
                }
            })
            .onBLExecuted(
                // BL実行後の遷移先の一覧
                new RoutingTable().map("success", DBListActivity.class )

                // onBLExecutedにこれを渡せば，BLの実行結果にかかわらず画面遷移を常に抑止。
                //STAY_THIS_PAGE_ALWAYS

                // BL実行結果が特定の状況のときのみ，画面遷移を抑止することも可能。
                //new RoutingTable().map("success", STAY_THIS_PAGE )

            )
            .startControl();
        ;

    }
}}}

 引用元：FuncDBController.java<br>
 http://code.google.com/p/android-mvc-framework/source/browse/tags/20120323_ver0.2/src/com/android_mvc/sample_project/controller/FuncDBController.java


バリデーションは行なわないで済ませる，等の柔軟な書き変えも可能。

{{{
    /**
     * HTTP通信画面からの遷移時
     */
    public static void submit(final HttpNetActivity activity)
    {
        new ControlFlowDetail<HttpNetActivity>( activity )
            .setValidation( new ValidationExecutor(){
                @Override
                public ValidationResult doValidate()
                {
                    // バリデーション処理
                    return new FuncNetValidation().validate( activity );
                }

                @Override
                public void onValidationFailed()
                {
                    showErrMessages();

                    // バリデーション失敗時の遷移先
                    stayInThisPage();
                }
            })
            .setBL( new BLExecutor(){
                @Override
                public ActionResult doAction()
                {
                    // BL
                    return new HttpNetAction( activity ).exec();
                }
            })
            .onBLExecuted(
                // BL実行後の遷移先
                STAY_THIS_PAGE_ALWAYS
            )
            .startControl();
        ;

    }
}}}

 引用元：FuncNetController.java<br>
 http://code.google.com/p/android-mvc-framework/source/browse/tags/20120323_ver0.2/src/com/android_mvc/sample_project/controller/FuncNetController.java


もし，ビジネスロジックを実行した後で，その結果を参照しつつUI操作を実行したい場合は，Activity側に下記のようなメソッドを置くだけで実行される。

ここでは，HTTP通信ロジックの処理結果を参照している。

{{{
    @Override
    public void afterBLExecuted(ActionResult ares)
    {
        UIUtil.longToast(this, "通信処理が完了しました。");

        // 通信の結果を表示
        HttpPostResponse response = (HttpPostResponse)ares.get("http_response");
        if( response.isSuccess() )
        {
            tv2.setText( response.getText() );
        }
        else
        {
            tv2.setText( response.getErrMsg() );
        }
    }
}}}

 引用元：HttpNetActivity.java<br>
 http://code.google.com/p/android-mvc-framework/source/browse/tags/20120323_ver0.2/src/com/android_mvc/sample_project/activities/func_net/HttpNetActivity.java


なお，コントローラの処理フローは，UIスレッドとは別のスレッド上で非同期で行なわれる。

したがって，その上に記述されるDB操作やHTTP通信などのビジネスロジックは，非同期を意識することなく，全く同期的に（単一スレッドモデルとして）記述できる。


=== ■バリデーション・ロジックが，きわめて簡潔に記述できるようになった。 ===

アクティビティ上の値の妥当性を検証するために，ユーザが記述するコードの量が，劇的に減った。

{{{
    /**
     * DB登録画面での入力値を検証
     */
    public ValidationResult validate(DBEditActivity activity)
    {
        initValidationOf(activity);

        assertNotEmpty("name");

        assertNotEmpty("age");
        assertValidInteger("age");
        assertNumberOperation("age", greaterThan(0));

        return getValidationResult();
    }
}}}

JUnit等でおなじみの，assert系のメソッドを並べるだけでいい。

このようにバリデーションメソッドが共通化された結果，

「○○は△△で入力してください。」のようなエラーメッセージは，フレームワーク内部で自動的に構築される事になった。

よって，検証処理自体も，検証結果の通知処理も，大幅に実装の手間が減った。

 引用元：FuncDBValidation.java<br>
 http://code.google.com/p/android-mvc-framework/source/browse/tags/20120323_ver0.2/src/com/android_mvc/sample_project/controller/FuncDBValidation.java


ユーザが自由にバリデーションメソッドを追加する事も可能である。


なお，本機能のアイデアの着想については，下記ページの情報を参照のこと。

 「バリデーション」APIと「単体テスト」APIの類似性，およびそのスタイルが時代と共に洗練される過程の概観<br>
 http://d.hatena.ne.jp/language_and_engineering/20120320/p1


=== ■エンティティを含む任意の自作オブジェクトが，Intent経由で気軽に運搬可能になった。 ===

IntentPortable（インテント経由で運搬可能である事を表すためのインタフェース）が導入された。

ユーザは任意のオブジェクトに対して，「implements IntentPortable」するだけで，そのオブジェクトをIntent経由で運搬可能になる。

エンティティやバリデーション結果など，フレームワーク内の主要なオブジェクトは，自動的に「IntentPortable」になる。

その結果，画面連携の負担が大幅に削減される。
<br>

下記にサンプルコードを掲載する。


Activity上で，送られてきたIntentからデータを取り出す側のコード：

{{{
        if( $.actionResultHasKey( "new_friend_obj" ) )
        {
            // Intentから情報を取得
            Friend f = (Friend)($.getActionResult().get("new_friend_obj"));

            // UIに表示
            tv2.text(f.getName() + "さんが，たった今新規登録されました。").visible();
        }
}}}

ビジネスロジックの実行結果やバリデーションの実行結果は，遷移先の画面に向かう際に，自動的にIntentの中に格納される。

つまり，処理の結果を遷移先の画面に運搬したい場合，ビジネスロジックの実行結果（ActionResultオブジェクト）に詰め込んでおけばよい。
ということになる。

もし手動で任意のオブジェクトを格納したい場合は，上述の通り，Router#goWithData などのメソッドを使えばよい。


 引用元：DBListActivity.java<br>
 http://code.google.com/p/android-mvc-framework/source/browse/tags/20120323_ver0.2/src/com/android_mvc/sample_project/activities/func_db/DBListActivity.java


本機能の着想については，下記ページの情報を参照のこと。

 Android SDKの，ParcelableとSerializableの違いを比較 - Intentで独自オブジェクトを運搬する際，役立つのはどちら？<br>
 http://d.hatena.ne.jp/language_and_engineering/20120313/p1






　